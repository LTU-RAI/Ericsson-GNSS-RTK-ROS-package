# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from ublox_msg/UbxNavPvt.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import ublox_msg.msg

class UbxNavPvt(genpy.Message):
  _md5sum = "b8c1d3ea328b86777476acb01b7d6bc4"
  _type = "ublox_msg/UbxNavPvt"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """uint32 i_tow
uint16 year
uint8  month
uint8  day
uint8  hour
uint8  min
uint8  sec
Valid  valid_data
uint32 t_acc
int32  nano
uint8  fix_type
Flags  flags_data
Flags2 flags2_data
uint8  num_sv
float64 lon
float64  lat
float64  height
int32  h_msl
uint32 h_acc
uint32 v_acc
int32  vel_n
int32  vel_e
int32  vel_d
int32  g_speed
int32  head_mot
uint32 s_acc
uint32 head_acc
uint16 p_dop
Flags3 flags3_data
uint8[4]  reserved0
int32  head_veh
int16  mag_dec
uint16 mag_acc
================================================================================
MSG: ublox_msg/Valid
uint8 valid_date
uint8 valid_time
uint8 fully_resolved
uint8 valid_mag
================================================================================
MSG: ublox_msg/Flags
uint8   gnss_fix_ok
uint8   diff_soln
uint8   psm_state
uint8   head_veh_valid
uint8   carr_soln
================================================================================
MSG: ublox_msg/Flags2
uint8 confirmed_avai
uint8 confirmed_date
uint8 confirmed_time
================================================================================
MSG: ublox_msg/Flags3
uint8 invalid_llh
uint8 last_correction_arg"""
  __slots__ = ['i_tow','year','month','day','hour','min','sec','valid_data','t_acc','nano','fix_type','flags_data','flags2_data','num_sv','lon','lat','height','h_msl','h_acc','v_acc','vel_n','vel_e','vel_d','g_speed','head_mot','s_acc','head_acc','p_dop','flags3_data','reserved0','head_veh','mag_dec','mag_acc']
  _slot_types = ['uint32','uint16','uint8','uint8','uint8','uint8','uint8','ublox_msg/Valid','uint32','int32','uint8','ublox_msg/Flags','ublox_msg/Flags2','uint8','float64','float64','float64','int32','uint32','uint32','int32','int32','int32','int32','int32','uint32','uint32','uint16','ublox_msg/Flags3','uint8[4]','int32','int16','uint16']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       i_tow,year,month,day,hour,min,sec,valid_data,t_acc,nano,fix_type,flags_data,flags2_data,num_sv,lon,lat,height,h_msl,h_acc,v_acc,vel_n,vel_e,vel_d,g_speed,head_mot,s_acc,head_acc,p_dop,flags3_data,reserved0,head_veh,mag_dec,mag_acc

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(UbxNavPvt, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.i_tow is None:
        self.i_tow = 0
      if self.year is None:
        self.year = 0
      if self.month is None:
        self.month = 0
      if self.day is None:
        self.day = 0
      if self.hour is None:
        self.hour = 0
      if self.min is None:
        self.min = 0
      if self.sec is None:
        self.sec = 0
      if self.valid_data is None:
        self.valid_data = ublox_msg.msg.Valid()
      if self.t_acc is None:
        self.t_acc = 0
      if self.nano is None:
        self.nano = 0
      if self.fix_type is None:
        self.fix_type = 0
      if self.flags_data is None:
        self.flags_data = ublox_msg.msg.Flags()
      if self.flags2_data is None:
        self.flags2_data = ublox_msg.msg.Flags2()
      if self.num_sv is None:
        self.num_sv = 0
      if self.lon is None:
        self.lon = 0.
      if self.lat is None:
        self.lat = 0.
      if self.height is None:
        self.height = 0.
      if self.h_msl is None:
        self.h_msl = 0
      if self.h_acc is None:
        self.h_acc = 0
      if self.v_acc is None:
        self.v_acc = 0
      if self.vel_n is None:
        self.vel_n = 0
      if self.vel_e is None:
        self.vel_e = 0
      if self.vel_d is None:
        self.vel_d = 0
      if self.g_speed is None:
        self.g_speed = 0
      if self.head_mot is None:
        self.head_mot = 0
      if self.s_acc is None:
        self.s_acc = 0
      if self.head_acc is None:
        self.head_acc = 0
      if self.p_dop is None:
        self.p_dop = 0
      if self.flags3_data is None:
        self.flags3_data = ublox_msg.msg.Flags3()
      if self.reserved0 is None:
        self.reserved0 = b'\0'*4
      if self.head_veh is None:
        self.head_veh = 0
      if self.mag_dec is None:
        self.mag_dec = 0
      if self.mag_acc is None:
        self.mag_acc = 0
    else:
      self.i_tow = 0
      self.year = 0
      self.month = 0
      self.day = 0
      self.hour = 0
      self.min = 0
      self.sec = 0
      self.valid_data = ublox_msg.msg.Valid()
      self.t_acc = 0
      self.nano = 0
      self.fix_type = 0
      self.flags_data = ublox_msg.msg.Flags()
      self.flags2_data = ublox_msg.msg.Flags2()
      self.num_sv = 0
      self.lon = 0.
      self.lat = 0.
      self.height = 0.
      self.h_msl = 0
      self.h_acc = 0
      self.v_acc = 0
      self.vel_n = 0
      self.vel_e = 0
      self.vel_d = 0
      self.g_speed = 0
      self.head_mot = 0
      self.s_acc = 0
      self.head_acc = 0
      self.p_dop = 0
      self.flags3_data = ublox_msg.msg.Flags3()
      self.reserved0 = b'\0'*4
      self.head_veh = 0
      self.mag_dec = 0
      self.mag_acc = 0

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_IH9BIi10B3di2I5i2IH2B().pack(_x.i_tow, _x.year, _x.month, _x.day, _x.hour, _x.min, _x.sec, _x.valid_data.valid_date, _x.valid_data.valid_time, _x.valid_data.fully_resolved, _x.valid_data.valid_mag, _x.t_acc, _x.nano, _x.fix_type, _x.flags_data.gnss_fix_ok, _x.flags_data.diff_soln, _x.flags_data.psm_state, _x.flags_data.head_veh_valid, _x.flags_data.carr_soln, _x.flags2_data.confirmed_avai, _x.flags2_data.confirmed_date, _x.flags2_data.confirmed_time, _x.num_sv, _x.lon, _x.lat, _x.height, _x.h_msl, _x.h_acc, _x.v_acc, _x.vel_n, _x.vel_e, _x.vel_d, _x.g_speed, _x.head_mot, _x.s_acc, _x.head_acc, _x.p_dop, _x.flags3_data.invalid_llh, _x.flags3_data.last_correction_arg))
      _x = self.reserved0
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(_get_struct_4B().pack(*_x))
      else:
        buff.write(_get_struct_4s().pack(_x))
      _x = self
      buff.write(_get_struct_ihH().pack(_x.head_veh, _x.mag_dec, _x.mag_acc))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.valid_data is None:
        self.valid_data = ublox_msg.msg.Valid()
      if self.flags_data is None:
        self.flags_data = ublox_msg.msg.Flags()
      if self.flags2_data is None:
        self.flags2_data = ublox_msg.msg.Flags2()
      if self.flags3_data is None:
        self.flags3_data = ublox_msg.msg.Flags3()
      end = 0
      _x = self
      start = end
      end += 101
      (_x.i_tow, _x.year, _x.month, _x.day, _x.hour, _x.min, _x.sec, _x.valid_data.valid_date, _x.valid_data.valid_time, _x.valid_data.fully_resolved, _x.valid_data.valid_mag, _x.t_acc, _x.nano, _x.fix_type, _x.flags_data.gnss_fix_ok, _x.flags_data.diff_soln, _x.flags_data.psm_state, _x.flags_data.head_veh_valid, _x.flags_data.carr_soln, _x.flags2_data.confirmed_avai, _x.flags2_data.confirmed_date, _x.flags2_data.confirmed_time, _x.num_sv, _x.lon, _x.lat, _x.height, _x.h_msl, _x.h_acc, _x.v_acc, _x.vel_n, _x.vel_e, _x.vel_d, _x.g_speed, _x.head_mot, _x.s_acc, _x.head_acc, _x.p_dop, _x.flags3_data.invalid_llh, _x.flags3_data.last_correction_arg,) = _get_struct_IH9BIi10B3di2I5i2IH2B().unpack(str[start:end])
      start = end
      end += 4
      self.reserved0 = str[start:end]
      _x = self
      start = end
      end += 8
      (_x.head_veh, _x.mag_dec, _x.mag_acc,) = _get_struct_ihH().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_IH9BIi10B3di2I5i2IH2B().pack(_x.i_tow, _x.year, _x.month, _x.day, _x.hour, _x.min, _x.sec, _x.valid_data.valid_date, _x.valid_data.valid_time, _x.valid_data.fully_resolved, _x.valid_data.valid_mag, _x.t_acc, _x.nano, _x.fix_type, _x.flags_data.gnss_fix_ok, _x.flags_data.diff_soln, _x.flags_data.psm_state, _x.flags_data.head_veh_valid, _x.flags_data.carr_soln, _x.flags2_data.confirmed_avai, _x.flags2_data.confirmed_date, _x.flags2_data.confirmed_time, _x.num_sv, _x.lon, _x.lat, _x.height, _x.h_msl, _x.h_acc, _x.v_acc, _x.vel_n, _x.vel_e, _x.vel_d, _x.g_speed, _x.head_mot, _x.s_acc, _x.head_acc, _x.p_dop, _x.flags3_data.invalid_llh, _x.flags3_data.last_correction_arg))
      _x = self.reserved0
      # - if encoded as a list instead, serialize as bytes instead of string
      if type(_x) in [list, tuple]:
        buff.write(_get_struct_4B().pack(*_x))
      else:
        buff.write(_get_struct_4s().pack(_x))
      _x = self
      buff.write(_get_struct_ihH().pack(_x.head_veh, _x.mag_dec, _x.mag_acc))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.valid_data is None:
        self.valid_data = ublox_msg.msg.Valid()
      if self.flags_data is None:
        self.flags_data = ublox_msg.msg.Flags()
      if self.flags2_data is None:
        self.flags2_data = ublox_msg.msg.Flags2()
      if self.flags3_data is None:
        self.flags3_data = ublox_msg.msg.Flags3()
      end = 0
      _x = self
      start = end
      end += 101
      (_x.i_tow, _x.year, _x.month, _x.day, _x.hour, _x.min, _x.sec, _x.valid_data.valid_date, _x.valid_data.valid_time, _x.valid_data.fully_resolved, _x.valid_data.valid_mag, _x.t_acc, _x.nano, _x.fix_type, _x.flags_data.gnss_fix_ok, _x.flags_data.diff_soln, _x.flags_data.psm_state, _x.flags_data.head_veh_valid, _x.flags_data.carr_soln, _x.flags2_data.confirmed_avai, _x.flags2_data.confirmed_date, _x.flags2_data.confirmed_time, _x.num_sv, _x.lon, _x.lat, _x.height, _x.h_msl, _x.h_acc, _x.v_acc, _x.vel_n, _x.vel_e, _x.vel_d, _x.g_speed, _x.head_mot, _x.s_acc, _x.head_acc, _x.p_dop, _x.flags3_data.invalid_llh, _x.flags3_data.last_correction_arg,) = _get_struct_IH9BIi10B3di2I5i2IH2B().unpack(str[start:end])
      start = end
      end += 4
      self.reserved0 = str[start:end]
      _x = self
      start = end
      end += 8
      (_x.head_veh, _x.mag_dec, _x.mag_acc,) = _get_struct_ihH().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_4B = None
def _get_struct_4B():
    global _struct_4B
    if _struct_4B is None:
        _struct_4B = struct.Struct("<4B")
    return _struct_4B
_struct_4s = None
def _get_struct_4s():
    global _struct_4s
    if _struct_4s is None:
        _struct_4s = struct.Struct("<4s")
    return _struct_4s
_struct_IH9BIi10B3di2I5i2IH2B = None
def _get_struct_IH9BIi10B3di2I5i2IH2B():
    global _struct_IH9BIi10B3di2I5i2IH2B
    if _struct_IH9BIi10B3di2I5i2IH2B is None:
        _struct_IH9BIi10B3di2I5i2IH2B = struct.Struct("<IH9BIi10B3di2I5i2IH2B")
    return _struct_IH9BIi10B3di2I5i2IH2B
_struct_ihH = None
def _get_struct_ihH():
    global _struct_ihH
    if _struct_ihH is None:
        _struct_ihH = struct.Struct("<ihH")
    return _struct_ihH
